;Audio on the GameTank is generated by a second 6502 processor, which controls a DAC
;This coprocessor only has access to this DAC and 4K of dual-ported memory, shared with the main processor.
;The coprocessor sees this memory from $0000 through $0FFF and repeated on every KB up to $FFFF
;The main processor only sees this memory between $3000 and $3FFF

;The DAC will be written on any byte where A15 is high.
;ie. on any address $8000 or higher.
DAC = $8000

;skippping $0 as it will be clobbered by DAC writes
rate_input = $1
;rate_input+1 = $2
counter = $3
;counter+1 = $4

;We'll include setting the first five ZP bytes to zero for this coprogram.
    .org $0000
    .db 0, 0, 0, 0, 0

	.org $0200
RESET:
    CLI
Forever:
    JMP Forever

;Audio coprograms for the GameTank mainly run from IRQ vector
;A hardware timer generates these interrupts to produce a steady sample rate.
;When the coprocessor outputs a sample, it writes to a buffer register.
;The same hardware timer signal also copies this buffer to the actual DAC.

;For this simplified example the coprogram will strictly generate a square wave.
;The main processor will control the pitch by writing to rate_input.
;On the coprocessor rate_input will be added to a 2-byte counter, and then
;the highest bit of the counter will be used as the square wave output.
IRQ:
    CLC
    LDA counter
    ADC rate_input
    STA counter
    LDA counter+1
    ADC rate_input+1
    STA counter+1
    ROL
    LDA #$FF
    ADC #$00
    STA DAC
    RTI

;An NMI can be triggered by the main processor
;Though TBH I haven't thought of a good use for this yet.
;Maybe someone else can?
NMI:
    RTI

    .org $0FFA
	.dw NMI
	.dw RESET
	.dw IRQ